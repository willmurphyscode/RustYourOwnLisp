use std::str::FromStr;
use opcode;
use std::rc::Rc;

grammar; 

pub SExpression : opcode::SExpression = {
    Num => opcode::SExpression::atomic(<>),
    "(" <o:OpCode> <v:Values> ")" => { 
        let mut vals = v.iter()
            .map(|item| Box::new(item.clone()))
            .collect(); 
        opcode::SExpression::op(
        opcode::Operation{ 
            opcode : o, 
            values : vals //.iter().map(|item| Rc::new(item)).collect()
            }
        )
    }
};

pub Values = Space<SExpression>;


Space<T>: Vec<T> = { // (1)
    <v:(<T> " ")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};


pub Num : f64 = r"((-)|(\+))?[0-9]+\.?[0-9]*" => f64::from_str(<>).unwrap();

pub OpCode : opcode::OpCode =  {
    "+" => opcode::OpCode::Add,
    "-" => opcode::OpCode::Subtract,
    "*" => opcode::OpCode::Multiply,
    "/" => opcode::OpCode::Divide,
};